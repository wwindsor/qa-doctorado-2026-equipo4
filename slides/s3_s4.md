# Presentación Equipo 4 — Revisión Semanas 3 y 4 (Máx. 6 slides)

**SUT:** Restful Booker (API REST, gestión de reservas)  
**Fuentes:** `risk/`, `design/`, `evidence/week3/`, `evidence/week4/`

---

## Slide 1 — Semana 3: Top 3 riesgos (priorización)
**SUT:** Restful Booker  
**Fuente (repo):** `risk/risk_matrix.csv`

**Top 3 riesgos (score + justificación breve):**
- **R1 — R001:** Pérdida de datos de reservas en base de datos (Impacto 5 / Prob 4 / Score 20) — porque el impacto es crítico (pérdida total de datos) y la probabilidad es alta en sistemas sin backups automatizados.
- **R2 — R003:** Degradación de performance bajo carga concurrente (Impacto 4 / Prob 4 / Score 16) — porque el impacto en la experiencia de usuario es alto y la probabilidad es alta en APIs REST sin optimización de concurrencia.
- **R3 — R002:** Acceso no autorizado a reservas sin autenticación adecuada (Impacto 5 / Prob 3 / Score 15) — porque el impacto es crítico (exposición de datos sensibles) aunque la probabilidad es media si hay validación básica.

**Qué decisión de priorización tomamos (1 frase):** Priorizamos por score (Impact × Probability); los tres mayores scores (20, 16, 15) se eligieron como Top 3; el resto (R004–R010) quedó en BACKLOG para ciclos posteriores.

---

## Slide 2 — Semana 3: trazabilidad (Riesgo → Escenario → Evidencia → Oráculo → Residual)
**Fuente (repo):** `risk/test_strategy.md` y `evidence/week3/`

| Riesgo (Top) | Escenario (E/Entorno/R/Medida) | Evidencia (archivo) | Oráculo (pass/fail) | Riesgo residual (1 línea) |
|---|---|---|---|---|
| R001 | Q5 Persistencia — E: local, reinicio SUT; R: datos idénticos pre/post reinicio | `evidence/week3/persistency_test_20260128_143022.log` | PASS: GET retorna mismos campos tras reinicio | Corrupción en reincios múltiples o fallos de hardware no validados |
| R003 | Q6 Carga concurrente — E: local; R: 10 POST concurrentes, latencia ≤2s | `evidence/week3/concurrent_load_test_20260128_143145.log` | PASS: 10/10 HTTP 200, IDs únicos, latencia max 156ms | Degradación bajo >100 req/s o carga sostenida >1h |
| R002 | Q7 Rechazo sin token — E: local; R: PUT sin token rechazado, datos intactos | `evidence/week3/authentication_failure_20260128_143245.log` | PASS: HTTP 403, datos no modificados | Ataques avanzados (IDOR, session fixation, token expirado) |

---

## Slide 3 — Semana 3: riesgo residual (qué queda fuera y por qué)
**Riesgos NO priorizados (al menos 2):**
- **R004** (Indisponibilidad del servicio, score 12): queda fuera porque el score es menor; hay cobertura parcial con smoke en week2.
- **R005** (Inconsistencia JSON entre versiones, score 9): queda fuera por impacto moderado y porque el SUT no expone versionado de API explícito en este ciclo.

**Riesgo residual clave (1 párrafo corto):**  
Queda abierto: (1) corrupción de datos en reincios repetidos o fallos no controlados, (2) degradación bajo carga sostenida o >100 req/s, (3) ataques de autorización avanzados (IDOR, token expirado). Es aceptable por ahora porque el alcance es académico y los tres riesgos críticos están mitigados con evidencia. Para reducirlo: añadir pruebas de estrés, reincios múltiples y pruebas de autorización granular (usuario A no puede ver reserva de usuario B).

---

## Slide 4 — Semana 4: objeto de prueba + técnica sistemática
**Objeto de prueba (endpoint/función):** `GET /booking/{id}`  
**Fuente (repo):** `design/test_cases.md`

**Por qué es buen candidato (al menos 2 razones):**
- El parámetro `{id}` tiene **variedad de entrada** (válidos, inválidos, tipo incorrecto, límites 0/-1/99999), lo que permite particiones de equivalencia y valores límite bien definidos.
- Los **criterios de éxito/fallo son claros** (HTTP 200 vs 4xx, estructura JSON, contrato de fechas) y existe **lógica de dominio** (checkin < checkout) para oráculos fuertes.

**Técnica usada (marcar una):**
- [x] EQ/BV (equivalencia + valores límite)
- [ ] Pairwise / combinatoria

**Cómo derivamos los casos (2–3 líneas):**  
Particionamos el dominio de entrada en clases de equivalencia (IDs válidos existentes, válidos no existentes, tipo inválido) y aplicamos valores límite (0, -1, 99999, 999999999, "abc", "", "null", "12.5"). De ahí derivamos 15 casos con TC-ID, cada uno ligado a oráculos concretos (OR-001 a OR-006).

**Cobertura que afirmamos (1–2 líneas) y qué NO afirmamos (1 línea):**
- **Afirmamos:** Cobertura de las clases de equivalencia y valores límite del parámetro ID, validez de estructura/tipos de respuesta y coherencia semántica de fechas (checkin < checkout).
- **No afirmamos:** Rendimiento, concurrencia, otros endpoints (POST/PUT/DELETE), autenticación ni comportamiento en red/tiempo real.

---

## Slide 5 — Semana 4: oráculos defendibles (mínimos vs estrictos)
**Fuente (repo):** `design/oracle_rules.md` y `evidence/week4/`

**Reglas de oráculo (mín. 5, marcar cuáles son "mínimas" y cuáles "estrictas"):**
- (Mínima) OR-1: HTTP 200 para solicitud exitosa (OR-001)
- (Mínima) OR-2: Respuesta JSON válida con campos requeridos (OR-002)
- (Mínima) OR-3: Fechas en formato YYYY-MM-DD (OR-003)
- (Estricta) OR-4: Consistencia de tipos (firstname/lastname string, totalprice number, depositpaid boolean) (OR-004)
- (Estricta) OR-5: Coherencia lógica de fechas (checkin < checkout) (OR-005)
- (Estricta) OR-6: Integridad de datos (recuperado = almacenado, sin corrupción) (OR-006)

**Ambigüedad detectada y cómo se resolvió (2–3 líneas):**  
ID vacío (ruta sin ID) e ID decimal ("12.5") devuelven HTTP 200 en el SUT en lugar de 404; el comportamiento es específico del SUT. Se documentó como **AMBIGUOUS** (TC-009, TC-011) en RUNLOG y summary, sin cambiar el oráculo, para clarificación futura con la especificación.

**Evidencia clave (2 archivos):**
- `evidence/week4/RUNLOG.md`
- `evidence/week4/TC-001_response.json` (ejemplo de caso exitoso; existen TC-001 a TC-015)

---

## Slide 6 — Validez + mejora concreta
**Amenazas a la validez (1 línea cada una):**
- **Interna:** Dependencia de datos de prueba (bookings preexistentes) → Mitigación futura: script de auto-setup que crea reservas antes de ejecutar; ya aplicado en `systematic_cases.sh`.
- **Constructo:** Posible sesgo en la selección de casos → Mitigación futura: uso de método EQ/BV sistemático (derivado de particiones explícitas) y documentación de limitaciones en `reports/week4_report.md`.
- **Externa:** Restful Booker es API de demostración; resultados no generalizan directamente a producción → Mitigación futura: la metodología (EQ/BV, oráculos en capas) es estándar y aplicable a otras APIs; documentar alcance en informes.

**Mejora concreta para la próxima quincena (1 bullet):**
- Resolver o documentar formalmente los casos ambiguos TC-009 (ID vacío) y TC-011 (ID decimal) frente a la especificación del SUT y, si aplica, extender oráculos para IDs malformados.

**Cierre (1 frase):**
- "Lo más defendible del trabajo del equipo es la **trazabilidad completa** (riesgo → escenario → oráculo → evidencia) y el **diseño sistemático** con EQ/BV y oráculos en capas (débiles + fuertes); el límite principal es el **alcance a un solo endpoint** y a un **SUT de demostración**, sin pruebas de rendimiento ni de otros riesgos del BACKLOG."
