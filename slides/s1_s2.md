# Presentación — Semanas 1 y 2 (Restful Booker)

---

## Slide 1 — Semana 1 (Pregunta 1 + Respuesta 1)

**Pregunta 1:** ¿Qué tipo de evidencia de pruebas reduce incertidumbre sobre calidad sin confundir “testing” con “quality assurance”?

**Respuesta 1:**

- La evidencia de pruebas que reduce incertidumbre sobre la calidad de software se refiere a artefactos, datos o documentación producidos durante las actividades de testing que permiten evaluar objetivamente qué tan bien el software satisface sus requisitos y comportamientos esperados. Esta evidencia ayuda a tomar decisiones fundamentadas sobre la preparación del producto para su uso o liberación, sin confundirla con las actividades más amplias de Quality Assurance (QA), que incluyen planificación, procesos y mejoras sistémicas.

- Por ejemplo, un test de sistema que valida el flujo de registro de usuarios puede generar como evidencia un test case documentado, el resultado esperado, el resultado observado y un registro de ejecución que muestre un fallo específico al ingresar un correo inválido. Esa evidencia reduce la incertidumbre sobre el comportamiento del sistema en ese escenario concreto. En cambio, actividades como auditorías de proceso, planes de calidad o métricas organizacionales pertenecen a quality assurance, ya que no prueban el software, sino que generan confianza en cómo se desarrolla y se prueba.

**Evidencia S1 (con oráculo + archivo):**

- API accesible y documentada: **SUT disponible**
  - Oráculo: HTTP responde + interfaz accesible
  - Evidencia: `evidence/week1/screencapture-localhost-3001-2026-01-17-23_56_37.png`, `evidence/week1/screencapture-localhost-3001-apidoc-index-html-2026-01-17-23_56_46.png`
- Operación básica: **Operaciones CRUD responden**
  - Oráculo: HTTP 200/201 + JSON bien formado
  - Evidencia: `evidence/week2/smoke_20260121_122251.log`
- Manejo de operaciones básicas: **GET, POST, DELETE funcionan**
  - Oráculo: HTTP 200/201/204 según operación
  - Evidencia: `evidence/week2/createBooking_20260121_122255.log`, `evidence/week2/getBookingById_20260121_122306.log`, `evidence/week2/deleteBooking_20260121_122258.log`
- Tiempo preliminar local (baseline):
  - Oráculo: registrar tiempos de respuesta en logs (sin afirmar producción)
  - Evidencia: timestamps en `evidence/week2/*.log`

**Límite (clave):**

- “Esta evidencia no prueba seguridad ni ausencia de defectos; solo reduce incertidumbre sobre disponibilidad/contrato/operación mínima en entorno local.”

---

## Slide 2 — Semana 2 (Pregunta 2 + Respuesta 2)

**Pregunta 2:** ¿Cómo convertir “calidad” en afirmaciones falsables y medibles?

**Respuesta 2:**

- Convertir “calidad” en afirmaciones falsables y medibles consiste en formular escenarios concretos con métricas y umbrales claros, respaldados por evidencia reproducible y con límites de validez explícitos. De este modo, la calidad deja de ser una opinión subjetiva y se convierte en una hipótesis técnica evaluable, coherente con el vocabulario del ISTQB y con un enfoque de ingeniería orientado a la reducción de riesgo, tal como proponen arc42, ATAM y Software Engineering at Google.

**2 escenarios estrella (de `quality/scenarios.md`):**

- **Escenario A — Operaciones CRUD básicas (Disponibilidad funcional)**
  - Estímulo: Ejecutar smoke tests (POST crear reserva → GET obtener → PUT actualizar → DELETE eliminar)
  - Entorno: local, Docker, ejecución única
  - Respuesta: HTTP 200/201/204 + JSON bien formado
  - Medida: `http_code` y presencia de datos en respuesta
  - Evidencia: `evidence/week2/smoke_20260121_122251.log`, `evidence/week2/createBooking_20260121_122255.log`, `evidence/week2/updateBooking_20260121_145747.log`, `evidence/week2/deleteBooking_20260121_122258.log`
  - Falsación: si alguna operación retorna error (5xx) o respuesta vacía
- **Escenario B — Robustez ante ID inválido en GET**
  - Estímulo: GET `/booking/{id}` con ID inexistente
  - Entorno: local, sin carga, 1 ejecución
  - Respuesta: no retornar 200 para IDs inválidos (esperado: 404 o similar)
  - Medida: `http_code` capturado en log
  - Evidencia: `evidence/week2/getBookingById_20260121_122306.log`
  - Falsación: si devuelve HTTP 200 para ID inexistente, el escenario queda refutado

**Mini-tabla (Claim→Escenario→Métrica→Evidencia→Oráculo):**

| Claim                               | Escenario                                     | Métrica                            | Evidencia (archivo)                                                                               | Oráculo (pass/fail)                         |
| ----------------------------------- | --------------------------------------------- | ---------------------------------- | ------------------------------------------------------------------------------------------------- | ------------------------------------------- |
| SUT accesible                       | Q1 Disponibilidad API                         | Captura de pantalla + interfaz web | `evidence/week1/screencapture-*.png`                                                              | pass si acceso confirmado visualmente       |
| Operaciones CRUD funcionan          | Q2 Smoke tests (Create, Read, Update, Delete) | `http_code` en logs                | `evidence/week2/smoke_*.log`, `createBooking_*.log`, `updateBooking_*.log`, `deleteBooking_*.log` | pass si todos HTTP 200/201/204              |
| GET con ID inválido no devuelve 200 | Q3 Robustez entrada (ID inexistente)          | `http_code` en log                 | `evidence/week2/getBookingById_*.log`                                                             | pass si `http_code != 200` para ID inválido |

---

## Slide 3 — Método formalizado

1. Definimos claims acotados sobre Restful Booker en entorno local:
   - SUT accesible y funcional (captura visual + logs de respuesta)
   - Operaciones CRUD básicas operativas (smoke tests)
   - Robustez ante entradas inválidas (GET con ID inexistente)

2. Los expresamos como escenarios verificables (Estímulo–Entorno–Respuesta–Medida) documentados en `quality/scenarios.md`.

3. Definimos oráculos mínimos:
   - Disponibilidad: interfaz web accesible (capturas en week1)
   - CRUD: HTTP 200/201/204 + JSON válido (logs en week2)
   - Robustez: HTTP ≠ 200 para IDs inválidos (log getBookingById)

4. Generamos evidencia reproducible con scripts shell (`scripts/*.sh`) y la versionamos:
   - `evidence/week1/`: capturas de pantalla (accesibilidad del SUT)
   - `evidence/week2/`: logs de ejecución (\*.log con timestamps y códigos HTTP)

**Fuentes para definición de método:**

- ISTQB: oráculo y objetivos de prueba (criterio de pass/fail).
- SWE@Google: testing como reducción de riesgo y claridad de pruebas.
- arc42/ATAM: escenarios medibles y verificables (no adjetivos).

---

## Slide 4 — Validez (amenazas y límites)

- **Interna:**
  - Ejecución de scripts depende del estado del SUT (puerto 3001, Docker activo).
  - Mitigación: verificar startup con `setup/healthcheck_sut.sh` antes de pruebas y documentar estado inicial en logs.
  - Variabilidad en timestamps de ejecución → registrar fecha/hora exacta en cada log.

- **Constructo:**
  - CRUD local no prueba escalabilidad, concurrencia ni seguridad en producción.
  - Mitigación: acotar claims a "disponibilidad funcional local" y operaciones CRUD básicas, sin afirmar calidad para carga real.
  - Oráculos simples (HTTP code) no detectan lógica de negocio errónea.

- **Externa:**
  - Resultados en máquina local pueden no reproducirse en otros entornos/configuraciones Docker.
  - Mitigación: documentar versiones (Docker, Node.js, puerto), repetir ejecución de scripts (`scripts/*.sh`) múltiples veces y comparar logs.
  - Capturas de pantalla (`evidence/week1/`) reflejan un instante; no garantizan estabilidad continua.

---

## Slide 5 — Cierre (3 conclusiones del proyecto)

- **Evidencia más fuerte:** disponibilidad funcional de CRUD en Restful Booker.
  - Smoke tests (`evidence/week2/smoke_*.log`) verifican que operaciones básicas (create, read, update, delete) responden con códigos HTTP válidos.
  - Falsación directa: si algún script retorna 5xx, el SUT no cumple mínimo de disponibilidad.

- **Límite más crítico:** claims locales no generalizan a producción.
  - Capturas en `evidence/week1/` muestran accesibilidad de la interfaz en un instante específico.
  - Logs en `evidence/week2/` documentan ejecución única sin garantizar estabilidad en carga o multi-usuario.
  - No afirmamos robustez ante ataques, concurrencia ni escalabilidad.

- **Mejora concreta (sin implementar hoy):**
  - Ejecutar scripts múltiples veces y agregar análisis de variabilidad en tiempos de respuesta.
  - Documentar explícitamente configuración del SUT (versión Node.js, memoria Docker, etc.) para reproducibilidad.
  - Definir umbrales de latencia (e.g., p95 < Xms) basados en requisitos de negocio y justificarlos.

---
