# Presentación — Semanas 1 y 2 (Restful Booker)

---

## Slide 1 — Semana 1 (Pregunta 1 + Respuesta 1)
**Pregunta 1:** ¿Qué tipo de evidencia de pruebas reduce incertidumbre sobre calidad sin confundir “testing” con “quality assurance”?

**Respuesta 1:**
- Agregar aqui respuesta grupal (1/2 párrafos)

**Evidencia S1 (con oráculo + archivo):**
- API accesible y documentada: **SUT disponible**  
  - Oráculo: HTTP responde + interfaz accesible  
  - Evidencia: `evidence/week1/screencapture-localhost-3001-2026-01-17-23_56_37.png`, `evidence/week1/screencapture-localhost-3001-apidoc-index-html-2026-01-17-23_56_46.png`
- Operación básica: **Operaciones CRUD responden**  
  - Oráculo: HTTP 200/201 + JSON bien formado  
  - Evidencia: `evidence/week2/smoke_20260121_122251.log`
- Manejo de operaciones básicas: **GET, POST, DELETE funcionan**  
  - Oráculo: HTTP 200/201/204 según operación  
  - Evidencia: `evidence/week2/createBooking_20260121_122255.log`, `evidence/week2/getBookingById_20260121_122306.log`, `evidence/week2/deleteBooking_20260121_122258.log`
- Tiempo preliminar local (baseline):  
  - Oráculo: registrar tiempos de respuesta en logs (sin afirmar producción)  
  - Evidencia: timestamps en `evidence/week2/*.log`

**Límite (clave):**  
- “Esta evidencia no prueba seguridad ni ausencia de defectos; solo reduce incertidumbre sobre disponibilidad/contrato/operación mínima en entorno local.”

---

## Slide 2 — Semana 2 (Pregunta 2 + Respuesta 2)
**Pregunta 2:** ¿Cómo convertir “calidad” en afirmaciones falsables y medibles?

**Respuesta 2:**
- Agregar aqui respuesta grupal (1/2 párrafos)

**2 escenarios estrella (de `quality/scenarios.md`):**
- **Escenario A — Operaciones CRUD básicas (Disponibilidad funcional)**  
  - Estímulo: Ejecutar smoke tests (POST crear reserva → GET obtener → PUT actualizar → DELETE eliminar)  
  - Entorno: local, Docker, ejecución única  
  - Respuesta: HTTP 200/201/204 + JSON bien formado  
  - Medida: `http_code` y presencia de datos en respuesta  
  - Evidencia: `evidence/week2/smoke_20260121_122251.log`, `evidence/week2/createBooking_20260121_122255.log`, `evidence/week2/updateBooking_20260121_145747.log`, `evidence/week2/deleteBooking_20260121_122258.log`  
  - Falsación: si alguna operación retorna error (5xx) o respuesta vacía
- **Escenario B — Robustez ante ID inválido en GET**  
  - Estímulo: GET `/booking/{id}` con ID inexistente  
  - Entorno: local, sin carga, 1 ejecución  
  - Respuesta: no retornar 200 para IDs inválidos (esperado: 404 o similar)  
  - Medida: `http_code` capturado en log  
  - Evidencia: `evidence/week2/getBookingById_20260121_122306.log`  
  - Falsación: si devuelve HTTP 200 para ID inexistente, el escenario queda refutado

**Mini-tabla (Claim→Escenario→Métrica→Evidencia→Oráculo):**

| Claim | Escenario | Métrica | Evidencia (archivo) | Oráculo (pass/fail) |
|---|---|---|---|---|
| SUT accesible | Q1 Disponibilidad API | Captura de pantalla + interfaz web | `evidence/week1/screencapture-*.png` | pass si acceso confirmado visualmente |
| Operaciones CRUD funcionan | Q2 Smoke tests (Create, Read, Update, Delete) | `http_code` en logs | `evidence/week2/smoke_*.log`, `createBooking_*.log`, `updateBooking_*.log`, `deleteBooking_*.log` | pass si todos HTTP 200/201/204 |
| GET con ID inválido no devuelve 200 | Q3 Robustez entrada (ID inexistente) | `http_code` en log | `evidence/week2/getBookingById_*.log` | pass si `http_code != 200` para ID inválido |

---

## Slide 3 — Método formalizado
1) Definimos claims acotados (disponibilidad mínima, robustez, baseline de latencia).  
2) Los expresamos como escenarios (E–Entorno–R–Medida) en `quality/scenarios.md`.  
3) Definimos oráculos mínimos (HTTP 200/404, JSON válido, HTTP != 200).  
4) Generamos evidencia reproducible con scripts y la versionamos en `evidence/week1` y `evidence/week2`.

**Fuentes para definición de método:**
- ISTQB: oráculo y objetivos de prueba (criterio de pass/fail).  
- SWE@Google: testing como reducción de riesgo y claridad de pruebas.  
- arc42/ATAM: escenarios medibles y verificables (no adjetivos).

---

## Slide 4 — Validez (amenazas y límites)
- **Interna:** warm-up/caché del contenedor afecta latencia → Mitigación: descartar primeras N corridas o reiniciar antes de medir.  
- **Constructo:** latencia local es proxy (no producción) → Mitigación: declarar el alcance “local baseline” y no extrapolar.  
- **Externa:** resultados dependen de máquina/red → Mitigación: registrar entorno (CPU/RAM/Docker) y repetir en otra máquina.  

---

## Slide 5 — Cierre (2 conclusiones)
- **Evidencia más fuerte:** robustez IDs inválidos (falsación directa: un 200 refuta el escenario).  
- **Límite más crítico:** mediciones locales no generalizan a producción (validez externa).  
- **Mejora concreta (sin implementar hoy):** definir umbral explícito y justificarlo (p95<=X) documentando entorno.

---
